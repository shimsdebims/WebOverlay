package com.example.weboverlay;

import android.content.Context;
import android.graphics.Color;
import android.graphics.Bitmap;
import android.util.Log;
import android.webkit.WebResourceError;
import android.webkit.WebResourceRequest;
import android.webkit.WebView;
import android.webkit.WebViewClient;
import android.graphics.Bitmap;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.net.Uri;
import android.os.Handler;
import android.util.Log;
import android.webkit.JavascriptInterface;
import android.webkit.WebResourceError;
import android.webkit.WebResourceRequest;
import android.webkit.WebView;
import android.webkit.WebViewClient;

import org.json.JSONException;
import org.json.JSONObject;

import java.io.IOException;
import java.net.URL;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.security.cert.CertificateException;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.FormBody;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;

/**
 * XiboWebClient extends WebViewClient to handle Xibo CMS integration.
 * This class manages authentication, layout loading, error handling, and connection monitoring.
 */
public class XiboWebClient extends WebViewClient {
    private static final String TAG = "XiboWebClient";
    private Context context;
    private WebView webView;
    private String cmsUrl;
    private XiboClientListener listener;

    public interface XiboClientListener {
        void onLayoutLoaded(String layoutId);
        void onLayoutLoadFailed(String layoutId, String reason);
    }

    /**
     * Constructor for XiboWebClient.
     * 
     * @param context Application context
     * @param webView The WebView instance to be controlled
     * @param cmsUrl Base URL of the Xibo CMS
     * @param clientId OAuth client ID
     * @param clientSecret OAuth client secret
     * @param username CMS username
     * @param password CMS password
     * @param listener Callback listener for client events
     */
    public XiboWebClient(Context context, WebView webView, String cmsUrl, XiboClientListener listener) {
        this.context = context;
        this.webView = webView;
        this.cmsUrl = cmsUrl;
        this.listener = listener;

        if (!this.cmsUrl.startsWith("http://") && !this.cmsUrl.startsWith("https://")) {
            this.cmsUrl = "http://" + this.cmsUrl;
        }
        
        configureWebView();
    }

    private void verifyCmsVersion() {
        String versionUrl = cmsUrl + "/api/about";
        Request request = new Request.Builder()
            .url(versionUrl)
            .build();

        createSecureOkHttpClient().newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                Log.e(TAG, "Failed to verify CMS version", e);
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                if (response.isSuccessful()) {
                    String body = response.body().string();
                    try {
                        JSONObject json = new JSONObject(body);
                        String version = json.optString("version");
                        Log.d(TAG, "Connected to Xibo CMS version: " + version);
                    } catch (JSONException e) {
                        Log.e(TAG, "Error parsing CMS version", e);
                    }
                }
            }
        });
    }

    /**
     * Configure WebView settings optimized for Xibo CMS display
     */
    private void configureWebView() {
        webView.getSettings().setJavaScriptEnabled(true);
        webView.getSettings().setDomStorageEnabled(true);
        webView.getSettings().setMediaPlaybackRequiresUserGesture(false);
        webView.setBackgroundColor(Color.TRANSPARENT);
        webView.setLayerType(WebView.LAYER_TYPE_HARDWARE, null);
    }
    public void loadLayout(String layoutId) {
        // Direct preview URL - no auth needed
        String previewUrl = String.format("%s/preview/%s?preview=1", cmsUrl, layoutId);
        Log.d(TAG, "Loading layout: " + previewUrl);
        
        webView.post(() -> {
            webView.loadUrl(previewUrl);
        });
    }
        // Check if we have a valid token already
        if (hasValidToken()) {
            if (listener != null) {
                listener.onAuthSuccess();
            }
            return;
        }

        OkHttpClient client = createSecureOkHttpClient();

        RequestBody formBody = new FormBody.Builder()
                .add("grant_type", "client_credentials")
                .add("client_id", clientId)
                .add("client_secret", clientSecret)
                .build();

        String authUrl = cmsUrl + "/api/oauth/token";
        Log.d(TAG, "Authenticating with URL: " + authUrl);
        Log.d(TAG, "Attempting connection to CMS at: " + cmsUrl);
        
        // Test CMS connection first
        Request testRequest = new Request.Builder()
            .url(cmsUrl)
            .build();
            
        client.newCall(testRequest).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                Log.e(TAG, "Failed to connect to CMS: " + e.getMessage());
                if (listener != null) {
                    listener.onAuthFailure("Cannot connect to CMS at " + cmsUrl + ": " + e.getMessage());
                }
            }
            
            @Override
            public void onResponse(Call call, Response response) throws IOException {
                Log.d(TAG, "CMS connection test successful, proceeding with authentication");
                // Now proceed with actual authentication

        Request request = new Request.Builder()
                .url(authUrl)
                .post(formBody)
                .addHeader("Content-Type", "application/x-www-form-urlencoded")
                .addHeader("Accept", "application/json")
                .addHeader("Authorization", "Basic " + android.util.Base64.encodeToString(
                    (clientId + ":" + clientSecret).getBytes(),
                    android.util.Base64.NO_WRAP))
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                Log.e(TAG, "Authentication failed: " + e.getMessage(), e);
                String errorMessage = "Network error: " + e.getMessage();
                if (e.getMessage() != null && e.getMessage().contains("Trust anchor for certification path not found")) {
                    errorMessage = "SSL Certificate error. The server's SSL certificate is not trusted.";
                    Log.e(TAG, "SSL Certificate validation failed. Consider using a valid certificate or enabling self-signed certificates for testing.");
                }
                if (listener != null) {
                    listener.onAuthFailure(errorMessage);
                }
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                try {
                    if (response.isSuccessful()) {
                        String responseData = response.body().string();
                        Log.d(TAG, "Auth response received, status: " + response.code());
                        JSONObject jsonObject = new JSONObject(responseData);
                        
                        // Save tokens to SharedPreferences
                        SharedPreferences prefs = context.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE);
                        SharedPreferences.Editor editor = prefs.edit();
                        
                        String accessToken = jsonObject.getString("access_token");
                        String refreshToken = jsonObject.getString("refresh_token");
                        long expiresIn = jsonObject.getLong("expires_in");
                        long expiryTime = System.currentTimeMillis() + (expiresIn * 1000);
                        
                        editor.putString(PREF_TOKEN, accessToken);
                        editor.putString(PREF_REFRESH_TOKEN, refreshToken);
                        editor.putLong(PREF_TOKEN_EXPIRY, expiryTime);
                        editor.apply();
                        
                        if (listener != null) {
                            listener.onAuthSuccess();
                        }
                    } else {
                        String responseBody = response.body() != null ? response.body().string() : "No response body";
                        String errorMessage = "Auth failed with code: " + response.code();
                        Log.e(TAG, errorMessage + ", Response: " + responseBody);
                        
                        // Try to extract more detailed error information
                        try {
                            JSONObject errorJson = new JSONObject(responseBody);
                            if (errorJson.has("error") || errorJson.has("message")) {
                                String detailedError = errorJson.optString("error", "") + ": " + 
                                                      errorJson.optString("message", "");
                                errorMessage += " - " + detailedError;
                            }
                        } catch (JSONException e) {
                            // Not JSON or doesn't have expected fields, use the raw response
                            if (!responseBody.isEmpty() && responseBody.length() < 100) {
                                errorMessage += " - " + responseBody;
                            }
                        }
                        
                        if (listener != null) {
                            listener.onAuthFailure(errorMessage);
                        }
                    }
                } catch (JSONException e) {
                    Log.e(TAG, "JSON parsing error", e);
                    if (listener != null) {
                        listener.onAuthFailure("Failed to parse response: " + e.getMessage());
                    }
                }
            }
        });
            }
        });
    }

    /**
     * Check if we have a valid access token
     */
    private boolean hasValidToken() {
        SharedPreferences prefs = context.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE);
        String token = prefs.getString(PREF_TOKEN, null);
        long expiry = prefs.getLong(PREF_TOKEN_EXPIRY, 0);
        
        // Add a 60-second buffer to ensure token doesn't expire during use
        return (token != null && System.currentTimeMillis() < (expiry - 60000));
    }

    /**
     * Refresh the access token using the refresh token
     */
    private void refreshToken() {
        SharedPreferences prefs = context.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE);
        String refreshToken = prefs.getString(PREF_REFRESH_TOKEN, null);
        
        if (refreshToken == null) {
            if (listener != null) {
                listener.onAuthFailure("No refresh token available");
            }
            return;
        }
        
        OkHttpClient client = createSecureOkHttpClient();

        RequestBody formBody = new FormBody.Builder()
                .add("grant_type", "client_credentials")
                .add("client_id", clientId)
                .add("client_secret", clientSecret)
                .build();

        Request request = new Request.Builder()
                .url(cmsUrl + "/api/oauth/token")
                .post(formBody)
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                Log.e(TAG, "Token refresh failed: " + e.getMessage(), e);
                
                String errorMessage = "Network error during token refresh: " + e.getMessage();
                if (e.getMessage() != null && e.getMessage().contains("Trust anchor for certification path not found")) {
                    errorMessage = "SSL Certificate error during token refresh. The server's SSL certificate is not trusted.";
                    Log.e(TAG, "SSL Certificate validation failed during token refresh.");
                }
                
                // If refresh fails, try full authentication
                authenticate();
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                try {
                    if (response.isSuccessful()) {
                        String responseData = response.body().string();
                        JSONObject jsonObject = new JSONObject(responseData);
                        
                        // Save tokens to SharedPreferences
                        SharedPreferences prefs = context.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE);
                        SharedPreferences.Editor editor = prefs.edit();
                        
                        String accessToken = jsonObject.getString("access_token");
                        String newRefreshToken = jsonObject.getString("refresh_token");
                        long expiresIn = jsonObject.getLong("expires_in");
                        long expiryTime = System.currentTimeMillis() + (expiresIn * 1000);
                        
                        editor.putString(PREF_TOKEN, accessToken);
                        editor.putString(PREF_REFRESH_TOKEN, newRefreshToken);
                        editor.putLong(PREF_TOKEN_EXPIRY, expiryTime);
                        editor.apply();
                        
                        // If we were trying to load a layout, retry now
                        if (currentLayoutId != null) {
                            loadLayout(currentLayoutId);
                        }
                    } else {
                        // If refresh fails, try full authentication
                        authenticate();
                    }
                } catch (JSONException e) {
                    Log.e(TAG, "JSON parsing error during token refresh", e);
                    authenticate();
                }
            }
        });
    }

    /**
     * Load a layout from Xibo CMS
     * 
     * @param layoutId The ID of the layout to load
     */
    public void loadLayout(String layoutId) {
        this.currentLayoutId = layoutId;
        currentRetryCount = 0;
        
        // Check if we need to authenticate first
        if (!hasValidToken()) {
            Log.d(TAG, "No valid token, authenticating first");
            authenticate();
            return;
        }
        
        try {
            SharedPreferences prefs = context.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE);
            String token = prefs.getString(PREF_TOKEN, "");
            
            // Build the layout preview URL for Xibo 3.3.3
            String layoutUrl = String.format("%s/layout/preview/%s?preview=1&access_token=%s", 
                cmsUrl, 
                layoutId,
                URLEncoder.encode(token, "UTF-8"));
            
            Log.d(TAG, "Loading layout URL: " + layoutUrl.replace(token, "***"));
        
        webView.post(() -> {
            // Clear cache and cookies before loading
            webView.clearCache(true);
            webView.clearHistory();
            
            // Set custom headers if needed
            Map<String, String> headers = new HashMap<>();
            headers.put("Authorization", "Bearer " + token);
            
            webView.loadUrl(layoutUrl, headers);
        });
    } catch (Exception e) {
        Log.e(TAG, "Error building layout URL", e);
        if (listener != null) {
            listener.onLayoutLoadFailed(layoutId, "URL construction error: " + e.getMessage());
        }
    }
}

    /**
     * Retry loading the current layout after a delay
     */
    private void retryLoadingLayout() {
        if (currentLayoutId == null) {
            return;
        }
        
        if (currentRetryCount < MAX_RETRIES) {
            currentRetryCount++;
            Log.d(TAG, "Retry " + currentRetryCount + " for layout " + currentLayoutId);
            
            new Handler().postDelayed(() -> loadLayout(currentLayoutId), RETRY_DELAY_MS);
        } else {
            Log.e(TAG, "Max retries reached for layout " + currentLayoutId);
            if (listener != null) {
                listener.onLayoutLoadFailed(currentLayoutId, "Max retries reached");
            }
            currentRetryCount = 0;
        }
    }

    /**
     * Start monitoring the network connection status
     */
    private void startConnectionMonitoring() {
        connectionChecker = new Runnable() {
            @Override
            public void run() {
                boolean newConnectionState = isNetworkAvailable();
                if (isConnected != newConnectionState) {
                    isConnected = newConnectionState;
                    if (listener != null) {
                        listener.onConnectionStateChanged(isConnected);
                    }
                    
                    // If connection was restored and we have a layout, try loading it
                    if (isConnected && currentLayoutId != null) {
                        loadLayout(currentLayoutId);
                    }
                }
                
                // Schedule the next check
                connectionHandler.postDelayed(this, 30000); // Check every 30 seconds
            }
        };
        
        // Start checking immediately
        connectionHandler.post(connectionChecker);
    }
    
    /**
     * Stop connection monitoring
     */
    public void stopConnectionMonitoring() {
        connectionHandler.removeCallbacks(connectionChecker);
    }
    
    /**
     * Check if network is available
     */
    private boolean isNetworkAvailable() {
        ConnectivityManager connectivityManager = (ConnectivityManager) 
                context.getSystemService(Context.CONNECTIVITY_SERVICE);
        if (connectivityManager != null) {
            NetworkInfo activeNetworkInfo = connectivityManager.getActiveNetworkInfo();
            return activeNetworkInfo != null && activeNetworkInfo.isConnected();
        }
        return false;
    }

    /**
     * Clean up resources when the client is no longer needed
     */
    public void cleanup() {
        stopConnectionMonitoring();
        webView.removeJavascriptInterface("XiboAndroid");
    }

    // WebViewClient overrides

    @Override
    public void onPageStarted(WebView view, String url, Bitmap favicon) {
        super.onPageStarted(view, url, favicon);
        Log.d(TAG, "Starting to load layout page: " + url);
    }

    @Override
    public void onPageFinished(WebView view, String url) {
        super.onPageFinished(view, url);
        Log.d(TAG, "Finished loading layout page: " + url);
        
        // Make background transparent
        String js = "document.body.style.backgroundColor = 'transparent';" +
                   "document.documentElement.style.backgroundColor = 'transparent';";
        view.evaluateJavascript(js, null);
        
        if (listener != null) {
            listener.onLayoutLoaded("1");  // Default layout ID
        }
    }

    @Override
    public void onReceivedError(WebView view, WebResourceRequest request, WebResourceError error) {
        super.onReceivedError(view, request, error);
        if (listener != null) {
            listener.onLayoutLoadFailed("1", "Failed to load layout");
        }
    }
        webView.evaluateJavascript(js, null);
        
        // Notify listener if this was a layout page
        if (url.contains("/layout/preview/") && listener != null) {
            listener.onLayoutLoaded(currentLayoutId);
        }
    }

    @Override
    public void onReceivedError(WebView view, WebResourceRequest request, WebResourceError error) {
        super.onReceivedError(view, request, error);
        
        // Only handle main frame errors
        if (request.isForMainFrame()) {
            String errorDescription;
            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.M) {
                errorDescription = "Error code: " + error.getErrorCode() + ", Description: " + error.getDescription();
            } else {
                errorDescription = "Error loading page";
            }
            Log.e(TAG, "Error loading page: " + errorDescription + ", URL: " + request.getUrl());
            
            // If this was a layout loading error, retry
            if (request.getUrl().toString().contains("/layout/preview/")) {
                retryLoadingLayout();
                retryLoadingLayout();
            }
        }
    }

    
    /**
     * Creates a secure OkHttpClient with proper SSL/TLS configuration
     */
    private OkHttpClient createSecureOkHttpClient() {
    OkHttpClient.Builder builder = new OkHttpClient.Builder()
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS);
    
    if (allowSelfSignedCertificates) {
        try {
            // Create a trust manager that accepts all certificates
            // WARNING: This is insecure and should only be used for development/testing
            final TrustManager[] trustAllCerts = new TrustManager[]{
                new X509TrustManager() {
                    @Override
                    public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                    }

                    @Override
                    public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                    }

                    @Override
                    public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                        return new java.security.cert.X509Certificate[]{};
                    }
                }
            };

            // Install the all-trusting trust manager
            final SSLContext sslContext = SSLContext.getInstance("SSL");
            sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
            
            // Create an SSL socket factory with our all-trusting manager
            final SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();

            builder.sslSocketFactory(sslSocketFactory, (X509TrustManager) trustAllCerts[0]);
            builder.hostnameVerifier(new HostnameVerifier() {
                @Override
                public boolean verify(String hostname, SSLSession session) {
                    return true; // Accept all hostnames
                }
            });
            
            Log.w(TAG, "Using insecure SSL configuration that accepts all certificates. NOT FOR PRODUCTION USE!");
        } catch (Exception e) {
            Log.e(TAG, "Error setting up SSL configuration", e);
        }
    }
    
    return builder.build();
}

    /**
     * Inject custom JavaScript into the page
     */
    private void injectCustomJavaScript() {
        // Example: inject code to handle transparent background
        String js = "document.body.style.backgroundColor = 'transparent';" +
                    "document.documentElement.style.backgroundColor = 'transparent';";
        webView.evaluateJavascript(js, null);
    }
    
    /**
     * JavaScript interface for communication between WebView and Android code
     */
    private class XiboJavaScriptInterface {
        
        @JavascriptInterface
        public void layoutEvent(String eventType, String data) {
            Log.d(TAG, "Layout event: " + eventType + " - " + data);
            // Handle various events from the layout (can be expanded based on needs)
        }
        
        @JavascriptInterface
        public void reportError(String errorMessage) {
            Log.e(TAG, "JS Error: " + errorMessage);
            // Can be used by layouts to report errors to Android
        }
        
        @JavascriptInterface
        public String getDeviceInfo() {
            // Return device info as JSON
            try {
                JSONObject info = new JSONObject();
                info.put("model", android.os.Build.MODEL);
                info.put("manufacturer", android.os.Build.MANUFACTURER);
                info.put("os", "Android " + android.os.Build.VERSION.RELEASE);
                info.put("appVersion", "1.0.0"); // Replace with actual version
                return info.toString();
            } catch (JSONException e) {
                Log.e(TAG, "Error creating device info", e);
                return "{}";
            }
        }
        
        @JavascriptInterface
        public void setLayerVisibility(String layerId, boolean visible) {
            // Can be used to control visibility of overlay elements
            Log.d(TAG, "Set layer " + layerId + " visibility to " + visible);
            // Implement layer visibility logic if needed
        }
    }
}

